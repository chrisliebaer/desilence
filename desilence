#!/bin/bash

# check input file
[ -z "$1" ] && echo "no filename given" && exit 1
[ ! -e "$1"  ] && echo "file not found: $1" && exit 1

export FILE="$1"
export BASENAME=`basename "$FILE"`

# configuration
export WORKER_POOL_SIZE=${WORKER_POOL_SIZE:-`nproc`}
export SILENCE_NOISE=${SILENCE_NOISE:-"-50dB"}
export SILENCE_DURATION=${SILENCE_DURATION-"0.5"}

# create working directory and register exit trap (DON'T TOUCH THIS LINE, you have been warned)
export WORK_DIR=`mktemp -p /tmp -d XXXXXXXXXX.desilence`
[ -z "$NO_CLEANUP" ] && trap 'rm -rf "$WORK_DIR"' EXIT

# the ffmpeg silence detect output
export FFMPEG_OUTPUT="$WORK_DIR/silencedetect.log"

# csv with segments of silence
export SILENCE_SEGMENTS="$WORK_DIR/silence-segments.csv"

# csv with segments of content
export WORKER_JOBS="$WORK_DIRsegments.csv"

# directory where worker store segments
export SEGMENT_DIR="$WORK_DIR/segments"
mkdir "$SEGMENT_DIR"

# file passed into ffmpeg to concat output file from segments
export CONCAT_FILE="$WORK_DIR/concat-file.txt"

########################################
## This script is run by each worker  ##
########################################
export WORKER_SCRIPT="$WORK_DIR/worker.sh"
cat > "$WORKER_SCRIPT" << 'EOF'
#!/bin/bash
[ -z "$1" ] && echo "No job given" && exit 1

JOB=$1

# execute job
seq=`echo "$JOB" | cut -d ',' -f 1`
start=`echo "$JOB" | cut -d ',' -f 2`
end=`echo "$JOB" | cut -d ',' -f 3`
dur=`echo "$JOB" | cut -d ',' -f 4`

ffmpeg -ss $start -i "$FILE" -t $dur "$SEGMENT_DIR/$seq.$start.$BASENAME" &> /dev/null
exit 0
EOF
chmod +x "$WORKER_SCRIPT"

echo "Using temporary working directory: $WORK_DIR"
echo "Detecting silence with $SILENCE_NOISE for $SILENCE_DURATION seconds on $WORKER_POOL_SIZE worker threads"

# make sure to wear eye protection before invoking ffmpeg
ffmpeg -i "$FILE" -af silencedetect=n=$SILENCE_NOISE:d=$SILENCE_DURATION -f null - 2>&1 | tee "$FFMPEG_OUTPUT"


# just your average bash hell
cat "$FFMPEG_OUTPUT" |
	sed -nr "s/^.*silence_start: ([0-9\.]+).*$/\1,/p; s/^.*silence_end: ([0-9\.]+).*silence_duration: ([0-9\.]+).*$/\1,\2;/p;" | # extract silence from ffmpeg output
	tr -d "\n" |						# remove new lines since the command above prepared the output for the next command
	sed "s/;/\n/g" |					# convert smicolon to new line
	grep -P "[0-9.]+,[0-9.]+,[0-9.]+" |	# if the video ends with silence there will be no end, so we simply ignore the last segment
	cat > "$SILENCE_SEGMENTS"			# just for symetry (please don't kill me cat-police)

# calculate total silence duration and segments
total_seqments=`cat $SILENCE_SEGMENTS | wc -l`
total_duration=0
for line in `cat $SILENCE_SEGMENTS`; do
	duration=`echo "$line" | cut -d ',' -f 3`
	total_duration=`echo "$duration + $total_duration" | bc`
done
echo "Total number of silence segments: $total_seqments"
echo "Total duration of silence: $total_duration seconds"

# ffmpeg gives silence segments but we need the inverse of that
# the following loop will invert all segments and make approriate ffmpeg invokations
echo "Converting ffmpeg output for worker pool"
start="0.00"
end="-1.00"
segnum=0
for line in `cat "$SILENCE_SEGMENTS"`; do
	l_start=`echo "$line" | cut -d ',' -f 1`
	l_end=`echo "$line" | cut -d ',' -f 2`
	
	# start of silence is where segment should be cut off
	end=$l_start

	# prepare job list for workers
	dur=`echo "$end - $start" | bc -l | sed 's/^\./0./'`
	seqnump=`printf "%010d" $segnum`
	echo "$seqnump,$start,$end,$dur" >> "$WORKER_JOBS"

	# next segment will start where current silence segment ends
	start=$l_end
	segnum=$((segnum+1))
done;

# start parallel processing in worker pool
echo "Running segment cutting with $WORKER_POOL_SIZE workers"
cat $WORKER_JOBS | parallel --no-notice --bar -P $WORKER_POOL_SIZE $WORKER_SCRIPT {}

# recombine video segments
echo "Rebuilding video from segments"
for file in $SEGMENT_DIR/*; do
	echo "file '$file'" >> "$CONCAT_FILE"
done
ffmpeg -f concat -i "$CONCAT_FILE" "desilence_$FILE"
